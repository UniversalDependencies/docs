<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>English grammatical relations</title>
    <link rel="root" href="../../"/> <!-- for JS -->
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->
  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
	
          <span class="header-text"><a href="http://universaldependencies.github.io/docs/#language-en">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <p>This page is an automatic merge of the pages with documentation and
examples from Section 2 of <em><a href="http://nlp.stanford.edu/software/dependencies_manual.pdf">Stanford typed dependencies
manual</a></em> (de
Marneffe and Manning 2008).</p>

<p>Note: <i>nmod</i>, <i>neg</i> and <i>punct</i> appear
in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td><a>nsubjpass</a></td>
	  <td><a>csubjpass</a></td>
	</tr>
	<tr>
	  <td><a>dobj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:npmod</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:tmod</a></td>
	</tr>
	<tr>
	  <td>↳<a>nmod:poss</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	  <td><a>auxpass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>expl</a></td>
	  <td><a>cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nummod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>acl:relcl</a></td>
	</tr>	
	<tr>
	  <td><a>appos</a></td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>det:predet</a></td>
	</tr>	
	<tr>
	  <td><a>nmod</a></td>
	   <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>mwe</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td>↳<a>compound:prt</a></td>
	</tr>
	<tr>
	  <td><a>name</a></td>
	  <td><a>foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>↳<a>cc:preconj</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking, prepositions, possessive</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>remnant</a></td>
	</tr>
	<tr>
	  <td><a>dislocated</a></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<p><a id="al-en-dep/acl" class="al-dest"></a></p>
<h2><code>acl</code>: clausal modifier of noun</h2>

<p><code>acl</code> is used for finite and non-finite clauses that modify a
noun. Note that in English relative clauses get assigned a specific
relation <a href="">acl:relcl</a>, a subtype of <code>acl</code>.</p>

<pre><code class="language-sdparse">the issues as he sees them
acl(issues, sees)
</code></pre>

<pre><code class="language-sdparse">Points to establish are ...
acl(Points, establish)
</code></pre>

<pre><code class="language-sdparse">I don't have anything to say to you
acl(anything, say)
</code></pre>

<p>Non-relative clause finite clausal complements for nouns are limited to complement clauses with a subset of nouns like <em>fact</em> or <em>report</em>.  We analyze them as <code>acl</code> (parallel to the analysis of this class as “content clauses” in Huddleston and Pullum 2002). Such clausal complements are usually finite (though there are occasional remnant English subjunctives). </p>

<pre><code class="language-sdparse">I admire the fact that you are honest 
acl(fact, honest) 
mark(honest, that) 
cop(honest, are) 
nsubj(honest, you) 
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/acl.md" target="#">edit acl</a></p>

<p><a id="al-en-dep/acl:relcl" class="al-dest"></a></p>
<h2><code>acl:relcl</code>: relative clause modifier</h2>

<p>A relative clause modifier of an noun is a relative clause modifying
the noun.  The relation points from the noun that is modified to the
head of the relative clause. Relative clauses are finite.</p>

<pre><code class="language-sdparse">I saw the man you love
acl:relcl(man, love)
</code></pre>

<pre><code class="language-sdparse">I saw the book which you bought
acl:relcl(book, bought)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/acl-relcl.md" target="#">edit acl:relcl</a></p>

<p><a id="al-en-dep/advcl" class="al-dest"></a></p>
<h2><code>advcl</code>: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.), as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an <a href="">advmod</a>) and the dependent is the main predicate of the clause.</p>

<pre><code class="language-sdparse">The accident happened as the night was falling
advcl(happened, falling)
</code></pre>

<pre><code class="language-sdparse">If you know who did it , you should tell the teacher
advcl(tell, know)
</code></pre>

<pre><code class="language-sdparse">He talked to him in order to secure the account
advcl(talked, secure)
</code></pre>

<pre><code class="language-sdparse">He was upset when I talked to him
advcl(upset, talked)
</code></pre>

<pre><code class="language-sdparse">They heard about you missing classes.
advcl(heard, missing)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/advcl.md" target="#">edit advcl</a></p>

<p><a id="al-en-dep/advmod" class="al-dest"></a></p>
<h2><code>advmod</code>: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) adverb or adverbial
phrase (ADVP) that serves to modify the meaning of the word.</p>

<pre><code class="language-sdparse">Genetically modified food
advmod(modified, Genetically)
</code></pre>

<pre><code class="language-sdparse">less often
advmod(often, less)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/advmod.md" target="#">edit advmod</a></p>

<p><a id="al-en-dep/amod" class="al-dest"></a></p>
<h2><code>amod</code>: adjectival modifier</h2>

<p>An adjectival modifier of an NP is any adjectival phrase that serves
to modify the meaning of the NP.</p>

<pre><code class="language-sdparse">Sam eats red meat
amod(meat, red)
</code></pre>

<pre><code class="language-sdparse">Sam took out  a 3 million dollar loan
amod(loan, dollar)
</code></pre>

<pre><code class="language-sdparse">Sam took out  a $ 3 million loan
amod(loan, $)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/amod.md" target="#">edit amod</a></p>

<p><a id="al-en-dep/appos" class="al-dest"></a></p>
<h2><code>appos</code>: appositional modifier</h2>

<p>An appositional modifier of an NP is an NP immediately to the right of the first NP that serves to define or modify that NP. It includes parenthesized examples, as well as defining abbreviations in one of these structures. </p>

<pre><code class="language-sdparse">Sam , my brother , arrived
appos(Sam-1, brother-4)
</code></pre>

<pre><code class="language-sdparse">Bill ( John 's cousin )
appos(Bill-1, cousin-5)
</code></pre>

<pre><code class="language-sdparse">The Australian Broadcasting Corporation ( ABC )
appos(Corporation-4, ABC-6)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/appos.md" target="#">edit appos</a></p>

<p><a id="al-en-dep/aux" class="al-dest"></a></p>
<h2><code>aux</code>: auxiliary</h2>

<p>An auxiliary of a clause is a non-main verb of the clause, e.g., a
modal auxiliary, or a form of <em>be</em>, <em>do</em> or <em>have</em> in a periphrastic
tense. </p>

<p>(Contrary to the older SD and arguments of Pullum (1982) and following,
infinitive <em>to</em> is not analyzed as an auxiliary. Instead, it is analyzed
as a <a href="">mark</a>.)</p>

<pre><code class="language-sdparse">Reagan has died
aux(died-3, has-2)
</code></pre>

<pre><code class="language-sdparse">He should leave
aux(leave-3, should-2)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/aux_.md" target="#">edit aux</a></p>

<p><a id="al-en-dep/auxpass" class="al-dest"></a></p>
<h2><code>auxpass</code>: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a non-main verb of the clause which
contains the passive information.</p>

<pre><code class="language-sdparse">Kennedy has been killed
auxpass(killed, been)
</code></pre>

<pre><code class="language-sdparse">Kennedy was killed
auxpass(killed, was)
</code></pre>

<pre><code class="language-sdparse">Kennedy got killed
auxpass(killed, got)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/auxpass.md" target="#">edit auxpass</a></p>

<p><a id="al-en-dep/case" class="al-dest"></a></p>
<h2><code>case</code>: case marking</h2>

<p>The <code>case</code> relation is used for any preposition in English. Prepositions are treated as dependents of the noun they attach to or introduce in an “extended nominal projection”. Thus, contrary to SD, UD abandons treating a preposition as a mediator between a modified word and its object. The <code>case</code> relation aims at providing a uniform analysis of prepositions and case in morphologically rich languages. In English, subordinating conjunctions introducing clauses are often in the form of prepositions. However, they are given a different dependency: The relation <a href="">mark</a> is used for markers in an “extended clausal projection”.</p>

<p>The <code>case</code> relation is also used for the possessive clitic <em>‘s</em> in English, which we separate from what it modifies, because it acts as a phrasal clitic, as shown in the last example.</p>

<pre><code class="language-sdparse">I saw a cat in a hat
case(hat, in)
</code></pre>

<pre><code class="language-sdparse">I saw a cat with a telescope
case(telescope, with)
</code></pre>

<pre><code class="language-sdparse">He is responsible for meals
case(meals, for)
</code></pre>

<pre><code class="language-sdparse">The school 's grounds
case(school, 's)
</code></pre>

<pre><code class="language-sdparse">The head of school 's speech
case(head, 's)
case(school, of)
nmod(speech, head)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/case.md" target="#">edit case</a></p>

<p><a id="al-en-dep/cc" class="al-dest"></a></p>
<h2><code>cc</code>: coordination</h2>

<p>A coordination is the relation between an element of a conjunct and the coordinating conjunction word of the conjunct.  (Note: different dependency grammars have different treatments of coordination.  We take one conjunct of a conjunction (normally the first) as the head of the conjunction.) A conjunction may also appear at the beginning of a sentence.  This is also called a <code>cc</code>, and dependent on the root predicate of the sentence. </p>

<pre><code class="language-sdparse">And then we left .
cc(left, And)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/cc.md" target="#">edit cc</a></p>

<p><a id="al-en-dep/cc:preconj" class="al-dest"></a></p>
<h2><code>cc:preconj</code>: preconjunct</h2>

<p>A preconjunct is the relation between the head of an NP and a word
that appears at the beginning bracketing a conjunction (and puts
emphasis on it), such as <em>either</em>, <em>both</em>, <em>neither</em>).</p>

<pre><code class="language-sdparse">Both the boys and the girls are here
cc:preconj(boys, Both)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/cc-preconj.md" target="#">edit cc:preconj</a></p>

<p><a id="al-en-dep/ccomp" class="al-dest"></a></p>
<h2><code>ccomp</code>: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause with an internal subject which functions like an object of the verb or adjective.  </p>

<pre><code class="language-sdparse">He says that you like to swim
ccomp(says, like)
</code></pre>

<pre><code class="language-sdparse">I am certain that he did it 
ccomp(certain, did) 
mark(did, that) 
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><a id="al-en-dep/compound" class="al-dest"></a></p>
<h2><code>compound</code>: compound</h2>

<p><em>compound</em> is used for </p>

<ul>
  <li>noun compounds (Note that in the current system for dependency extraction, all nouns modify the rightmost noun of the noun phrase – there is no intelligent noun compound analysis.  This is likely to be fixed once the Penn Treebank represents the branching structure of noun phrases.) </li>
</ul>

<pre><code class="language-sdparse">phone book
compound(book, phone)
</code></pre>

<pre><code class="language-sdparse">oil price futures
nn(futures, oil)
</code></pre>

<ul>
  <li>numbers</li>
</ul>

<pre><code class="language-sdparse">I have four thousand sheep
compound(thousand, four)
</code></pre>

<pre><code class="language-sdparse">I lost $ 3.2 billion
compound(billion, 3.2)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/compound.md" target="#">edit compound</a></p>

<p><a id="al-en-dep/compound:prt" class="al-dest"></a></p>
<h2><code>compound:prt</code>: phrasal verb particle</h2>

<p>The phrasal verb particle relation identifies a phrasal verb, and
holds between the verb and its particle. It is a subtype of the
<a href="">compound</a> relation.</p>

<pre><code class="language-sdparse">They shut down the station
compound:prt(shut, down)
</code></pre>

<pre><code class="language-sdparse">They shut the station down
compound:prt(shut, down)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/compound-prt.md" target="#">edit compound:prt</a></p>

<p><a id="al-en-dep/conj" class="al-dest"></a></p>
<h2><code>conj</code>: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as <em>and</em>, <em>or</em>, etc.  We treat
conjunctions asymmetrically: The head of the relation is the first
conjunct and other conjunctions depend on it via the <code>conj</code> relation.</p>

<pre><code class="language-sdparse">Bill is big and honest
conj(big, honest)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/conj.md" target="#">edit conj</a></p>

<p><a id="al-en-dep/cop" class="al-dest"></a></p>
<h2><code>cop</code>: copula</h2>

<p>A copula is the relation between the complement of a copular verb and
the copular verb. Copular heads are avoided when possible.</p>

<pre><code class="language-sdparse">Bill is an honest man
cop(man, is)
nsubj(man, Bill)
amod(man, honest)
det(man, an)
</code></pre>

<p>Prepositional phrases are annotated similarly, the only difference being that
the nominal predicate has an additional case marker.</p>

<pre><code class="language-sdparse">Bill is from California
case(California, from)
cop(California, is)
nsubj(California, Bill)
</code></pre>

<p>When an adjective or adverb is being predicated of a nominal phrase, the
adjective/adverb is the root, the nominal phrase is the nsubj, and the
copula is the cop.</p>

<pre><code class="language-sdparse">Bill is honest
nsubj(honest, Bill)
cop(honest, is)
</code></pre>

<pre><code class="language-sdparse">It was yesterday
nsubj(yesterday, it)
cop(yesterday, was)
</code></pre>

<p>Prepositions may also project a cop dependent.</p>

<pre><code class="language-sdparse">The light is on
cop(on, is)
nsubj(on, light)
det(light, the)
</code></pre>

<p>In predicative wh-constructions, the fronted wh-word is the head, and the copula is 
another cop.</p>

<pre><code class="language-sdparse">What is that ?
cop(What, is)
nsubj(What, that)
</code></pre>

<p>However, whenever the copula has a clausal argument/adjunct, the copula becomes the root, so the cop relation is not used.</p>

<pre><code class="language-sdparse">It was because Bill is honest
nsubj(was, It)
mark(honest, because)
ccomp(was, honest)
nsubj(honest, Bill)
cop(honest, is)
</code></pre>

<pre><code class="language-sdparse">My question is : was that really true ?
nsubj(is, question)
ccomp(is, true)
cop(true, was)
nsubj(true, that)
advmod(true, really)
</code></pre>

<pre><code class="language-sdparse">This is to inform you of our decision
nsubj(is, This)
advcl(is, inform)
aux(inform, to)
dobj(inform, you)
nmod(inform, decision)
case(decision, of)
poss(decision, our)
</code></pre>

<p>Predicative “be” is the only verb recognized as a copula; other copula-like verbs,such as “become”, “get”, and “seem”, are treated as regular raising verbs, and thus take xcomp arguments. Non-predicative uses of “be”–e.g., “be” when used in periphrastic verbal constructions, presentationals, or existentials–is annotated as an aux instead.
of a cop.</p>

<pre><code class="language-sdparse">Bill got rich
nsubj(got, Bill)
xcomp(got, rich)
</code></pre>

<pre><code class="language-sdparse">Bill is speaking
nsubj(speaking, Bill)
aux(speaking, is)
</code></pre>

<pre><code class="language-sdparse">Here are some bags
advmod(are, Here)
nsubj(are, bags)
det(bags, some)
</code></pre>

<pre><code class="language-sdparse">There 's a cow in the field
expl('s, There)
nsubj('s, cow)
det(cow, a)
nmod('s, field)
det(field, the)
case(field, in)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/cop.md" target="#">edit cop</a></p>

<p><a id="al-en-dep/csubj" class="al-dest"></a></p>
<h2><code>csubj</code>: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e., the subject is itself a clause. The governor of this relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb. In the two following examples, <em>what she said</em> is the subject. </p>

<pre><code class="language-sdparse">What she said makes sense
csubj(makes, said)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/csubj.md" target="#">edit csubj</a></p>

<p><a id="al-en-dep/csubjpass" class="al-dest"></a></p>
<h2><code>csubjpass</code>: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive
clause. In the example below, <em>that she lied</em> is the subject.</p>

<pre><code class="language-sdparse">That she lied was suspected by everyone
csubjpass(suspected, lied)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/csubjpass.md" target="#">edit csubjpass</a></p>

<p><a id="al-en-dep/dep" class="al-dest"></a></p>
<h2><code>dep</code>: dependent</h2>

<p>A dependency is labeled as <code>dep</code> when a system is unable to determine
a more precise dependency relation between two words.  This may be
because of a weird grammatical construction, a limitation in the
Stanford Dependency conversion software, a parser error, or because of
an unresolved long distance dependency.</p>

<pre><code class="language-sdparse">Then , as if to show that he could , ...
dep(show, if)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/dep.md" target="#">edit dep</a></p>

<p><a id="al-en-dep/det" class="al-dest"></a></p>
<h2><code>det</code>: determiner</h2>

<p>A determiner is the relation between the head of an NP and its determiner. </p>

<pre><code class="language-sdparse">The man is here
det(man, The)
</code></pre>

<pre><code class="language-sdparse">Which book do you prefer ?
det(book, Which)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/det.md" target="#">edit det</a></p>

<p><a id="al-en-dep/det:predet" class="al-dest"></a></p>
<h2><code>det:predet</code>: predeterminer</h2>

<p>A predeterminer is the relation between the head of an NP and a word
that precedes and modifies the meaning of the NP determiner.</p>

<pre><code class="language-sdparse">All the boys are here
det:predet(boys, All)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/det-predet.md" target="#">edit det:predet</a></p>

<p><a id="al-en-dep/discourse" class="al-dest"></a></p>
<h2><code>discourse</code>: discourse element</h2>

<p>This is used for interjections and other discourse particles and elements (which are not clearly linked to the structure of the sentence, except in an expressive way). We generally follow the guidelines of what the Penn Treebanks count as an INTJ.  They define this to include: interjections (<em>oh</em>, <em>uh-huh</em>, <em>Welcome</em>), fillers (<em>um</em>, <em>ah</em>), and discourse markers (<em>well</em>, <em>like</em>, <em>actually</em>, but not <em>you know</em>). </p>

<pre><code class="language-sdparse">Iguazu is in Argentina :)
discourse(is-2, :)-5)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/discourse.md" target="#">edit discourse</a></p>

<p><a id="al-en-dep/dislocated" class="al-dest"></a></p>
<h2><code>dislocated</code>: dislocated elements</h2>

<p>The <code>dislocated</code> relation is used for fronted or postposed elements
that do not fulfill the usual core grammatical relations of a
sentence. Dislocated elements are attached to the same governor as the dependent that they double for.</p>

<pre><code class="language-sdparse">This is our office , me and Sam
dislocated(office, me)
cc(me, and)
conj(me, Sam)
</code></pre>

<pre><code class="language-sdparse">The Mezza Luna : you should try it .
det(Luna-3, The-1)
compound(Luna-3, Mezza-2)
dislocated(it-8, Luna-3)
nsubj(try-7, you-5)
aux(try-7, should-6)
root(root-0, try-7)
dobj(try-7, it-8)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/dislocated.md" target="#">edit dislocated</a></p>

<p><a id="al-en-dep/dobj" class="al-dest"></a></p>
<h2><code>dobj</code>: direct object</h2>

<p>The direct object of a VP is the noun phrase which is the (accusative) object of the verb. </p>

<pre><code class="language-sdparse">She gave me a raise
dobj(gave, raise)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/dobj.md" target="#">edit dobj</a></p>

<p><a id="al-en-dep/expl" class="al-dest"></a></p>
<h2><code>expl</code>: expletive</h2>

<p>This relation captures an existential <em>there</em> or <em>it</em> in extraposition constructions. There is further discussion and examples on the universal dependency page (<a href="">u-dep/expl</a>).</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/expl.md" target="#">edit expl</a></p>

<p><a id="al-en-dep/foreign" class="al-dest"></a></p>
<h2><code>foreign</code>: foreign words</h2>

<p>We use <code>foreign</code> to label sequences of foreign words. These are given
a linear analysis: the head is the first token in the foreign phrase.</p>

<pre><code class="language-sdparse">I guess that c' est la vie
nsubj(guess-2, I-1)
ccomp(guess-2, c'-4)
mark(c'-4, that-3)
foreign(c'-4, est-5)
foreign(c'-4, la-6)
foreign(c'-4, vie-7)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/foreign.md" target="#">edit foreign</a></p>

<p><a id="al-en-dep/goeswith" class="al-dest"></a></p>
<h2><code>goeswith</code>: goes with</h2>

<p>This relation links two parts of a word that are separated in text
that is not well edited. We follow the treebank: The GW part is the
dependent and the head is in some sense the <em>main</em> part, often the
second part.</p>

<pre><code class="language-sdparse">They come here with out legal permission
goeswith(out-5, with-4)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/goeswith.md" target="#">edit goeswith</a></p>

<p><a id="al-en-dep/iobj" class="al-dest"></a></p>
<h2><code>iobj</code>: indirect object</h2>

<p>The indirect object of a VP is the noun phrase which is the (dative)
object of the verb.</p>

<pre><code class="language-sdparse">She gave me a raise
iobj(gave, me)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/iobj.md" target="#">edit iobj</a></p>

<p><a id="al-en-dep/list" class="al-dest"></a></p>
<h2><code>list</code>: list</h2>

<p>The <code>list</code> relation is used for chains of comparable items. Web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures in particular contain these structures, in the form of contact information: the different contact information items are labeled as <code>list</code>; the key-value pair relations are labeled as <a href="">appos</a>.</p>

<p>In lists with more than two items, all items of the list shoud modify the first one.</p>

<pre><code class="language-sdparse">Steve Jones Phone: 555-9814 Email: jones@abc.edf
name(Steve-1, Jones-2)
list(Steve-1, Phone:-3)
list(Steve-1, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
</code></pre>

<p>In an itemized or numbered list, we have been taking the item marker as a dependent of the head of the contentful list item. This appears to be better than the alternative.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/list.md" target="#">edit list</a></p>

<p><a id="al-en-dep/mark" class="al-dest"></a></p>
<h2><code>mark</code>: marker</h2>

<p>A marker is the word introducing a clause subordinate to another clause. For a complement clause, this will typically be <em>that</em> or <em>whether</em>. For an adverbial clause, the marker is typically a preposition like <em>before</em> or a subordinating conjunction fulfilling a similar role like <em>while</em> or <em>although</em>. The mark is a dependent of the subordinate clause head. </p>

<pre><code class="language-sdparse">Forces engaged in fighting after insurgents attacked
mark(attacked, after)
</code></pre>

<pre><code class="language-sdparse">He says that you like to swim
mark(swim, that)
</code></pre>

<p>The infinitive marker <em>to</em> is analyzed as a <code>mark</code>.</p>

<pre><code class="language-sdparse">I tried to finish it
mark(finish, to)
</code></pre>

<p>When a a noun or a verb takes a prepositionally marked non-core argument (modifier) and that modifier is a clause, then we also label that prepositon as <code>mark</code> (as it would not seem reasonable to call it <code>case</code> when it is marking a clause). The result will commonly be a doubly marked clause.</p>

<pre><code class="language-sdparse">We have no useful information on whether users are at risk .
nsubj(have, We)
neg(information, no)
amod(information, useful)
dobj(have, information)
mark(risk, on)
mark(risk, whether)
nsubj(risk, users)
cop(risk, are)
case(risk, at)
acl(information, risk)
punct(have, .)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/mark.md" target="#">edit mark</a></p>

<p><a id="al-en-dep/mwe" class="al-dest"></a></p>
<h2><code>mwe</code>: multi-word expression</h2>

<p>The multi-word expression (modifier) relation is used for certain fixed grammaticized expressions with function words that behave like a single function word. Multiword expressions are annotated in a flat, head-initial structure,
in which all words in the expression modify the first one using the
<code>mwe</code> label.</p>

<p>At present, this relation is used inside the following expressions: </p>

<p><em>as well</em></p>

<pre><code class="language-sdparse">I like dogs as well
advmod(like, as)
mwe(as, well)
</code></pre>

<p><em>as well as</em></p>

<pre><code class="language-sdparse">I like dogs as well as cats
mwe(as-4, well)
mwe(as-4, as-6)
cc(dogs, as-4)
</code></pre>

<p><em>such as</em></p>

<pre><code class="language-sdparse">I like fluffy animals , such as dogs
case(dogs, such)
mwe(such, as)
</code></pre>

<p><em>due to</em> (and other forms, such as <em>d t</em> and <em>d/t</em>)</p>

<pre><code class="language-sdparse">He cried due to the fact that you hurt him
case(fact, due)
mwe(due, to)
</code></pre>

<p><em>because of</em> (and other forms, such as <em>b c of</em> and <em>b/c of</em>)</p>

<pre><code class="language-sdparse">He cried because of you
case(you, because)
mwe(because, of)
</code></pre>

<p><em>instead of</em></p>

<pre><code class="language-sdparse">John went instead of Mary
mwe(instead, of)
case(Mary, instead)
</code></pre>

<pre><code class="language-sdparse">John left early instead of staying for the whole thing
mwe(instead, of)
mark(staying, instead)
</code></pre>

<p><em>in case</em></p>

<pre><code class="language-sdparse">I always back up my files in case my computer crashes
mwe(in, case)
mark(crashes, in)
</code></pre>

<pre><code class="language-sdparse">I always back up my files just in case
mwe(in, case)
advmod(back, in)
advmod(in, just)
</code></pre>

<p><em>in case of</em></p>

<pre><code class="language-sdparse">I always back up my files in case of a crash
mwe(in, case)
mwe(in, of)
case(crash, in)
</code></pre>

<p><em>of course</em></p>

<pre><code class="language-sdparse">I like dogs , of course
advmod(like, of)
mwe(of, course)
</code></pre>

<p><em>so that</em></p>

<pre><code class="language-sdparse">He cried so that you would feel bad
mark(feel, so)
mwe(so, that)
</code></pre>

<p><em>more than</em> (when used synonymously with “over” in a quantity)</p>

<pre><code class="language-sdparse">More than 90 percent
advmod(percent, More)
mwe(More, than)
</code></pre>

<p><em>less than</em> (when used synonymously with “under” in a quantity)</p>

<pre><code class="language-sdparse">Less than ten percent
advmod(percent, Less)
mwe(Less, than)
</code></pre>

<p><em>up to</em> (when used in quantities)</p>

<pre><code class="language-sdparse">Up to fifty percent
mwe(Up, to)
advmod(percent, Up)
</code></pre>

<p><em>according to</em></p>

<pre><code class="language-sdparse">According to John
mwe(According, to)
case(John, According)
</code></pre>

<p><em>in order</em></p>

<pre><code class="language-sdparse">He cried in order to make you feel bad
mark(feel, in)
mwe(in, order)
</code></pre>

<pre><code class="language-sdparse">He cried in order that you might feel bad
mark(feel, in)
mwe(in, order)
</code></pre>

<pre><code class="language-sdparse">He cried in order for you to have something to feel bad about
mark(have, in)
mwe(in, order)
</code></pre>

<p><em>rather than</em></p>

<pre><code class="language-sdparse">I decided to get a dog rather than a cat
mwe(rather, than)
cc(rather, dog)
</code></pre>

<p><em>at least</em> (when not used for quantities)</p>

<pre><code class="language-sdparse">At least I like dogs
mwe(At, least)
advmod(like, At)
</code></pre>

<p><em>as if</em></p>

<pre><code class="language-sdparse">It was as if he cried to make you feel bad
mwe(as, if)
mark(cried, as)
</code></pre>

<p><em>prior to</em></p>

<pre><code class="language-sdparse">John left prior to the meeting
mwe(prior, to)
case(meeting, prior)
</code></pre>

<p><em>as to</em></p>

<pre><code class="language-sdparse">As to whether I love dogs ...
mwe(As, to)
mark(love, As)
</code></pre>

<pre><code class="language-sdparse">As to my love of dogs ...
mwe(As, to)
case(love, As)
</code></pre>

<p><em>kind of</em></p>

<pre><code class="language-sdparse">I kind of like dogs
mwe(kind, of)
advmod(like, kind)
</code></pre>

<p><em>whether or not</em></p>

<pre><code class="language-sdparse">He 's crying whether or not you feel bad about it
mwe(whether, or)
mwe(whether, not)
mark(feel, whether)
</code></pre>

<p><em>not to mention</em></p>

<pre><code class="language-sdparse">This restaurant is pretty cheap with good food, not to mention their friendly staff
mwe(not, to)
mwe(not, mention)
cc(cheap, not)
conj(staff, cheap)
</code></pre>

<p><em>as opposed to</em></p>

<pre><code class="language-sdparse">John decided to leave early , as opposed to Mary
mwe(as, opposed)
mwe(as, to-9)
case(Mary, as)
</code></pre>

<p><em>let alone</em></p>

<pre><code class="language-sdparse">He could n't handle being hurt , let alone hurt by you
mwe(let, alone)
cc(hurt-6, alone)
conj(hurt-6, hurt-10)
</code></pre>

<p><em>so as to</em></p>

<pre><code class="language-sdparse">John left early so as to miss the meeting
mwe(so, as)
mwe(so, to)
mark(so, miss)
</code></pre>

<p><em>in between</em></p>

<pre><code class="language-sdparse">John left in between meetings
mwe(in, between)
case(in, meetings)
</code></pre>

<p><em>all but</em></p>

<pre><code class="language-sdparse">John has all but left
mwe(all, but)
advmod(all, left)
</code></pre>

<p><em>that is</em></p>

<pre><code class="language-sdparse">The dogs need to be housebroken -- that is , '' potty - trained ''
mwe(that, is)
advmod(trained, that)
</code></pre>

<p><em>how come</em></p>

<pre><code class="language-sdparse">How come John left early ?
mwe(How, come)
mark(left, How)
</code></pre>

<p><em>had better</em> (and <em>‘d better</em>)</p>

<pre><code class="language-sdparse">You had better apologize
mwe(had, better)
aux(had, apologize)
</code></pre>

<h3 id="not-mwes">Not <code>mwe</code>s</h3>
<p>The following are <strong>not</strong> annotated as <code>mwe</code>s, but are instead labeled according to their apparent internal structure.</p>

<p><em>out of</em>, <em>off of</em> (All double prepositions denoting spatial relations are annotated with two cases on the nominal)</p>

<pre><code class="language-sdparse">Get out of there !
nmod(Get, there)
case(there, out)
case(there, of)
</code></pre>

<pre><code class="language-sdparse">Get off of that !
nmod(Get, that)
case(that, off)
case(that, of)
</code></pre>

<p><em>by far</em></p>

<pre><code class="language-sdparse">Dogs are the best animal by far
nmod(animal, far)
case(far, by)
</code></pre>

<p><em>what about</em></p>

<pre><code class="language-sdparse">What about John ?
nmod(What, John)
case(John, about)
</code></pre>

<p><em>at all</em></p>

<pre><code class="language-sdparse">I don't like her at all
nmod(like, all)
case(all, at)
</code></pre>

<p><em>at most</em>, <em>at least</em> (when used for quantities. To determine whether <em>at least</em> should be an <code>mwe</code> or not in borderline cases, substitute it with <em>at most</em>; if the sentence remains grammatical, it should receive its surface analysis)</p>

<pre><code class="language-sdparse">at most 50 percent
npadvmod(percent, most)
case(most, at)
</code></pre>

<pre><code class="language-sdparse">at least 50 percent
npadvmod(percent, least)
case(least, at)
</code></pre>

<p><em>at best</em>, <em>at worst</em></p>

<pre><code class="language-sdparse">At best , they were guesses
npadvmod(guesses, best)
case(best, At)
</code></pre>

<pre><code class="language-sdparse">At worst , they were lies
npadvmod(lies, worst)
case(worst, At)
</code></pre>

<p><em>what if</em></p>

<pre><code class="language-sdparse">What if John left early ?
advcl(What, left)
mark(left, if)
</code></pre>

<p><em>so long</em></p>

<pre><code class="language-sdparse">So long , Ham 's ... you will be missed
advmod(long, So)
vocative(long, Ham)
parataxis(long, missed)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/mwe.md" target="#">edit mwe</a></p>

<p><a id="al-en-dep/name" class="al-dest"></a></p>
<h2><code>name</code>: name</h2>

<p><code>name</code> is one of the three relations for compounding in UD (together
with <a href="">compound</a> and <a href="">mwe</a>).
It is used for proper nouns constituted of multiple nominal
elements. For example, <code>name</code> would be used between the words of
<em>Hillary Rodham Clinton, New York,</em> or <em>Carl XVI Gustaf</em> but not to
replace the usual relations in a phrasal or clausal name like <em>The
king of Sweden</em> or the novels <em>The Lord of the Rings</em> and <em>Captured By
Aliens.</em>
Words joined by <code>name</code> should all be part of a minimal noun phrase;
otherwise regular syntactic relations should be used.  This is
basically similar to the treatment of noun compounds with
<a href="">compound</a>, except that in many cases parts of the name may be
another nominal element such as an adjective <em>(United Airlines).</em></p>

<p>In general, names are annotated in a flat, head-initial structure, in
which all words in the name modify the first one using the <code>name</code>
label.</p>

<pre><code class="language-sdparse">Carl XVI Gustaf
name(Carl-1, Gustaf-3)
name(Carl-1, XVI-2)
</code></pre>

<p>For organization names with clear syntactic modification structure, the dependencies should reflect the syntactic modification structure using regular syntactic relation, as in:.</p>

<pre><code class="language-sdparse">Natural Resources Conservation Service
amod(Resources-2, Natural-1)
compound(Conservation-3, Resources-2)
compound(Service-4, Conservation-3)
</code></pre>

<p>In addition, regular syntactic relations are used:
(i) for a modifying determiner or
(ii) to connect together the words of a description or name which involve embedded prepositional phrases, sentences, etc.</p>

<pre><code class="language-sdparse">Le Japon
det(Japon-2, Le-1)
</code></pre>

<pre><code class="language-sdparse">Ludwig van Beethoven
case(Beethoven, van)
</code></pre>

<pre><code class="language-sdparse">Miguel de Cervantes y Saavedra
conj(Cervantes, Saavedra)
cc(Cervantes, y)
case(Cervantes, de)
</code></pre>

<pre><code class="language-sdparse">The king of Sweden
det(king-2, The-1)
nmod(king-2, Sweden-4)
case(Sweden-4, of-3)
</code></pre>

<pre><code class="language-sdparse">Río de la Plata
case(Plata-4, de-2)
det(Plata-4, la-3)
nmod(Río-1, Plata-4)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/name.md" target="#">edit name</a></p>

<p><a id="al-en-dep/neg" class="al-dest"></a></p>
<h2><code>neg</code>: negation modifier</h2>

<p>The negation modifier is the relation between a negation word and the
word it modifies. It is used both for predicate negation (canonically, <em>not</em>) and nominal negation (canonically <em>no</em>). Dependents labeled <code>neg</code> in the current treebank are the following (in various lowercase/uppercase forms): <em>n, n’t, neither, never, no, non, not, nt, t</em>. </p>

<pre><code class="language-sdparse">Bill is not a scientist
neg(scientist, not)
</code></pre>

<pre><code class="language-sdparse">Bill does n't drive
neg(drive, n't)
</code></pre>

<pre><code class="language-sdparse">John saw no accidents
neg(accidents, no)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/neg.md" target="#">edit neg</a></p>

<p><a id="al-en-dep/nmod" class="al-dest"></a></p>
<h2><code>nmod</code>: nominal modifier</h2>

<p>The <code>nmod</code> relation is used for nominal modifiers of nouns or clausal
predicates. <code>nmod</code> is a noun functioning as a non-core (oblique)
argument or adjunct. In English, <code>nmod</code> is used</p>

<ul>
  <li>for prepositional complements:</li>
</ul>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<pre><code class="language-sdparse">give the toys to the children
dobj(give, toys)
nmod(give, children)
case(children, to)
</code></pre>

<p>The <code>nmod</code> relation holds between the noun/predicate modified by the
prepositional complement and the noun introduced by the preposition.</p>

<ul>
  <li>for ‘s genitives:</li>
</ul>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>

<p>Nominal modifiers not introduced by a preposition or not ‘s genitives
are tagged <a href="">nmod:npmod</a>, a subtype of <code>nmod</code>. Temporal nominal
modifiers are also marked with a separate relation <a href="">nmod:tmod</a>. See
the definitions of these relations.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod.md" target="#">edit nmod</a></p>

<p><a id="al-en-dep/nmod:npmod" class="al-dest"></a></p>
<h2><code>nmod:npmod</code>: noun phrase as adverbial modifier</h2>

<p>This relation is a subtype of the <a href="">nmod</a> relation, which captures
the following cases where something syntactically a noun phrase is
used as an adverbial modifier in a sentence:</p>

<p>(i) a measure phrase, which is the relation between the head of an adjectival/adverbial or prepositional phrase and the head of a measure phrase modifying it:</p>

<pre><code class="language-sdparse">The director is 65 years old
nmod:npmod(old, years)
</code></pre>

<pre><code class="language-sdparse">6 feet long
nmod:npmod(long, feet)
</code></pre>

<p>(ii) noun phrases giving an extent to a verb, which are not objects:</p>

<pre><code class="language-sdparse">Shares eased a fraction
nmod:npmod(eased, fraction)
</code></pre>

<p>(iii) financial constructions involving an adverbial, notably the following construction <em>$5 a share</em>, where the second nominal means “per share”:</p>

<pre><code class="language-sdparse">IBM earned $ 5 a share
nmod:npmod($, share)
</code></pre>

<p>(iv) floating reflexives</p>

<pre><code class="language-sdparse">The silence is itself significant
nmod:npmod(significant, itself)
</code></pre>

<p>and (v) certain other absolutive nominal constructions.</p>

<p>A temporal modifier <a href="">nmod:tmod</a> is a subclass of npmod which is
distinguished as a separate relation.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod-npmod.md" target="#">edit nmod:npmod</a></p>

<p><a id="al-en-dep/nmod:poss" class="al-dest"></a></p>
<h2><code>nmod:poss</code>: TODO</h2>

<p><code>nmod:poss</code> is used for a nominal modifier which occur before its head in the specifier position used for <em>‘s</em> possessives. It is marked with the <code>case</code> <em>‘s</em> or one of its variant forms. This relation isn’t used for other pre-head modifiers such as noun compounds or quotative phrases.</p>

<pre><code class="language-sdparse">Marie 's book
nmod:poss(book, Marie)
case(Marie, 's)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod-poss.md" target="#">edit nmod:poss</a></p>

<p><a id="al-en-dep/nmod:tmod" class="al-dest"></a></p>
<h2><code>nmod:tmod</code>: temporal modifier</h2>

<p>A temporal modifier is a subtype of the <a href="">nmod</a> relation: if the modifier is specifying a time, it is labeled as <em>tmod</em>. </p>

<pre><code class="language-sdparse">Last night , I swam in the pool
nmod:tmod(swam, night)
</code></pre>

<pre><code class="language-sdparse">You need to turn in your homework by next week
nmod:tmod(turn, week)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nmod-tmod.md" target="#">edit nmod:tmod</a></p>

<p><a id="al-en-dep/nsubj" class="al-dest"></a></p>
<h2><code>nsubj</code>: nominal subject</h2>

<p>A nominal subject is a noun phrase which is the syntactic subject of a clause. The governor of this relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb, which can be an adjective or noun. </p>

<pre><code class="language-sdparse">Clinton defeated Dole
nsubj(defeated, Clinton)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nsubj.md" target="#">edit nsubj</a></p>

<p><a id="al-en-dep/nsubjpass" class="al-dest"></a></p>
<h2><code>nsubjpass</code>: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.</p>

<pre><code class="language-sdparse">Dole was defeated by Clinton
nsubjpass(defeated, Dole)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nsubjpass.md" target="#">edit nsubjpass</a></p>

<p><a id="al-en-dep/nummod" class="al-dest"></a></p>
<h2><code>nummod</code>: numeric modifier</h2>

<p>A numeric modifier of a noun is any number phrase that serves to
modify the meaning of the noun with a quantity.</p>

<pre><code class="language-sdparse">Sam ate 3 sheep
nummod(sheep, 3)
</code></pre>

<pre><code class="language-sdparse">Sam spent forty dollars
nummod(dollars, forty)
</code></pre>

<pre><code class="language-sdparse">Sam spent $ 40
nummod($, 40)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/nummod.md" target="#">edit nummod</a></p>

<p><a id="al-en-dep/parataxis" class="al-dest"></a></p>
<h2><code>parataxis</code>: parataxis</h2>

<p>The parataxis relation (from Greek for “place side by side”) is a relation between the main verb of a clause and other sentential elements, such as a sentential parenthetical, a clause after a “:” or a “;”, or two sentences placed side by side without any explicit coordination or subordination. </p>

<pre><code class="language-sdparse">The guy , John said , left early in the morning
parataxis(left, said)
</code></pre>

<pre><code class="language-sdparse">Let 's face it we 're annoyed
parataxis(Let, annoyed)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/parataxis.md" target="#">edit parataxis</a></p>

<p><a id="al-en-dep/punct" class="al-dest"></a></p>
<h2><code>punct</code>: punctuation</h2>

<p>This is used for any piece of punctuation in a clause, if punctuation is being retained in the typed dependencies. By default, punctuation is not retained in the output. </p>

<pre><code class="language-sdparse">Go home !
punct(Go, !)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/punct.md" target="#">edit punct</a></p>

<p><a id="al-en-dep/remnant" class="al-dest"></a></p>
<h2><code>remnant</code>: remnant in ellipsis</h2>

<p>The <code>remnant</code> relation is used to provide a satisfactory treatment of ellipsis (in
the case of gapping and stripping, where a predicational or verbal
head gets elided) <em>without</em> having to postulate empty nodes in the basic representation. This is something that was lacking in earlier versions
of SD and provides a basis for being able to reconstruct dependencies
in the enhanced representation of SD. </p>

<p>USD adopts an analysis that notes that in ellipsis a <code>remnant</code> corresponds to a <em>correlate</em> in a preceding clause. The <code>remnant</code> relation connects each remnant to its correlate in the basic dependency representation. This is then a sufficient representation to reconstruct the predicate-argument structure in the enhanced representation.</p>

<pre><code class="language-sdparse">Marie went to Paris and Miriam to Prague
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
cc(went-2, and-5)
remnant(Marie-1, Miriam-6)
case(Prague-8, to-7)
remnant(Paris-4, Prague-8)
</code></pre>

<p>Even in the more complex example below, the <code>remnant</code>
relations enable us to correctly retrieve the subjects and objects in
the clauses with an elided verb.</p>

<pre><code class="language-sdparse">John won bronze , Mary silver , and Sandy gold
nsubj(won-2, John-1)
dobj(won-2, bronze-3)
remnant(John-1, Mary-5)
remnant(Mary-5, Sandy-9)
remnant(bronze-3, silver-6)
remnant(silver-6, gold-10)
</code></pre>

<p>Note in particular that (unlike for <a href="">conj</a>), <code>remnant</code> uses a chaining analysis where each subsequent remnant depends on the immediately preceding remnant/correlate. The reason for this is that otherwise in a sentence with 2 or more chained ellipses the dependency structure would no longer track which remnants go together. It would become impossible to determine whether Mary won silver and Sandy gold, or Mary won gold and Sandy silver.</p>

<p>Instances of stripping typically occur when there is only one argument in the second clause, but with an accompanying adverbial modifier such as <em>not</em> or <em>only</em>. We model these sentences with the remnant relation as well.</p>

<pre><code class="language-sdparse">Marie went to Paris , not Miriam
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
remnant(Marie-1, Miriam-7)
neg(Miriam-7, not-6)
</code></pre>

<pre><code class="language-sdparse">Marie did go to Europe , but only to Paris .
nsubj(go-3, Marie-1)
aux(go-3, did-2)
root(root-0, go-3)
case(Europe-5, to-4)
nmod(go-3, Europe-5)
cc(go-3, but-7)
advmod(Paris-10, only-8)
case(Paris-10, to-9)
remnant(Europe-5, Paris-10)
</code></pre>

<p>Sometimes in these constructions adverbials will be “sprouted”, and have no correlate in the precedeing clause. In such a situation, the adverbial should attach to one of the remnants; in principle it shouldn’t matter which remnant it attaches to, since all remnants at a particular depth of embedding point back to the same semantic event (which the adverbial is a part of). However, to enforce a regular system, the adverbial should depend on the nearest leftmost dependent. </p>

<pre><code class="language-sdparse">Mary will come today and Tom tomorrow , if he finds a ticket .
nsubj(come-3, Mary-1)
aux(come-3, will-2)
root(root-0, come-3)
advmod(come-3, today-4)
cc(come-3, and-5)
remnant(Mary-1, Tom-6)
remnant(today-4, tomorrow-7)
mark(finds-11, if-9)
nsubj(finds-11, he-10)
advcl(tomorrow-7, finds-11)
det(ticket-13, a-12)
dobj(finds-11, ticket-13)
</code></pre>

<pre><code class="language-sdparse">Mary will come today and , if he finds a ticket , Tom tomorrow .
nsubj(come-3, Mary-1)
aux(come-3, will-2)
root(root-0, come-3)
advmod(come-3, today-4)
cc(come-3, and-5)
mark(finds-9, if-7)
nsubj(finds-9, he-8)
advcl(Tom-13, finds-9)
det(ticket-11, a-10)
dobj(finds-9, ticket-11)
remnant(Mary-1, Tom-13)
remnant(today-4, tomorrow-14)
</code></pre>

<p>The <code>remnant</code> relation is used when no predicational material is present. In contrast, in right-node-raising (RNR) and VP-ellipsis constructions in which some kind of predicational or verbal material is still present, the <code>remnant</code> relation is not used. In RNR, the verbs are coordinated and the object is a <a href="">dobj</a> of the first verb:</p>

<pre><code class="language-sdparse">John bought and ate an apple
nsubj(bought-2, John-1)
cc(bought-2, and-3)
conj(bought-2, ate-4)
det(apple-6, an-5)
dobj(bought-2, apple-6)
</code></pre>

<p>In VP-ellipsis, we keep the auxiliary as the head, as shown below:</p>

<pre><code class="language-sdparse">John will win gold and Mary will too
nsubj(win-3, John-1)
aux(win-3, will-2)
dobj(win-3, gold-4)
cc(win-3, and-5)
conj(win-3, will-7)
nsubj(will-7, Mary-6)
advmod(will-7, too-8)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/remnant.md" target="#">edit remnant</a></p>

<p><a id="al-en-dep/reparandum" class="al-dest"></a></p>
<h2><code>reparandum</code>: overridden disfluency</h2>

<p>We use <code>reparandum</code> to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.</p>

<pre><code class="language-sdparse">Go to the righ- to the left .
nmod(Go-1, left-7)
reparandum(left-7, righ-)
case(righ-, to-2)
det(righ-, the-3)
case(left-7, to-5)
det(left-7, the-6)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/reparandum.md" target="#">edit reparandum</a></p>

<p><a id="al-en-dep/root" class="al-dest"></a></p>
<h2><code>root</code>: root</h2>

<p>The <code>root</code> grammatical relation points to the root of the sentence. A fake node “ROOT” is used as the governor. The ROOT node is indexed with “0”, since the indexation of real words in the sentence starts at 1. </p>

<pre><code class="language-sdparse">ROOT I love French fries .
root(ROOT, love)
</code></pre>

<pre><code class="language-sdparse">ROOT Bill is an honest man
root(ROOT, man)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/root.md" target="#">edit root</a></p>

<p><a id="al-en-dep/vocative" class="al-dest"></a></p>
<h2><code>vocative</code>: vocative</h2>

<p>The <code>vocative</code> relation is used to mark dialogue participant addressed
in text (common in emails and newsgroup postings). The relation links
the addressee’s name to its host sentence.</p>

<pre><code class="language-sdparse">Guys , take it easy!
vocative(take, Guys)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/vocative.md" target="#">edit vocative</a></p>

<p><a id="al-en-dep/xcomp" class="al-dest"></a></p>
<h2><code>xcomp</code>: open clausal complement</h2>

<p>An open clausal complement (<code>xcomp</code>) of a verb or an adjective is a predicative or clausal complement without its own subject. The reference of the subject is necessarily determined by an argument external to the xcomp (normally by the object of the next higher clause, if there is one, or else by the subject of the next higher clause. These complements are always non-finite, and they are complements (arguments of the higher verb or adjective) rather than adjuncts/modifiers, such as a purpose clause. The name <code>xcomp</code> is borrowed from Lexical-Functional Grammar. </p>

<pre><code class="language-sdparse">He says that you like to swim
xcomp(like, swim)
</code></pre>

<pre><code class="language-sdparse">Sue asked George to respond to her offer
xcomp(asked, respond)
</code></pre>

<pre><code class="language-sdparse">I consider him a fool
xcomp(consider, fool)
</code></pre>

<pre><code class="language-sdparse">I consider him honest
xcomp(consider, honest)
</code></pre>

<pre><code class="language-sdparse">She looks very beautiful
xcomp(looks, beautiful)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-dep/xcomp.md" target="#">edit xcomp</a></p>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'http://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'http://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'en-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.github.io/docs/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
