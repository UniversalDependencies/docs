<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Dependencies</title>
    <link rel="root" href="../../"/> <!-- for JS -->
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->
  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
	
          <span class="header-text"><a href="http://universaldependencies.github.io/docs/#language-cs">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <h1 id="dependencies">Dependencies</h1>

<p>Note: <i>nmod</i>, <i>neg</i>, and <i>punct</i> appear
in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td><a>nsubjpass</a></td>
	  <td><a>csubjpass</a></td>
	</tr>
	<tr>
	  <td><a>dobj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>advmod:emph</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	  <td><a>auxpass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>expl</a></td>
	  <td>↳<a>auxpass:reflex</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a>cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td><a>appos</a></td>
	  <td>&nbsp;</td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>det:numgov</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>det:nummod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>nummod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>nummod:gov</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>mwe</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>name</a></td>
	  <td>↳<a>mwe:reflex</a></td>
	  <td><a>foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking, prepositions, possessive</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>remnant</a></td>
	</tr>
	<tr>
	  <td><a>dislocated</a></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<p><a id="al-cs-dep/acl" class="al-dest"></a></p>
<h2><code>acl</code>: clausal modifier of noun</h2>

<p><code>acl</code> stands for finite and non-finite clauses that modify a nominal.  The <code>acl</code> relation 
contrasts with the <a href="">advcl</a> relation, which is used for adverbial clauses
that modify a predicate. The head of the <code>acl</code> relation is the noun
that is modified, and the dependent is the head of the clause that
modifies the noun.</p>

<pre><code class="language-sdparse">muž , o kterém jsem mluvil \n man , about whom I-have talked
acl(muž, mluvil)
acl(man, talked)
</code></pre>

<p>This relation is also used for optional depictives.
The adjective is taken to modify the nominal of which it provides a secondary predication.
See <a href="">u-dep/xcomp</a> for further discussion of resultatives and depictives.</p>

<pre><code class="language-sdparse">Alena vstoupila do místnosti smutná . \n Alena entered to room sad .
acl(Alena-1, smutná)
acl(Alena-8, sad)
</code></pre>

<pre><code class="language-sdparse">Namaloval svou ženu nahou . \n He-painted his wife naked .
acl(ženu, nahou)
acl(wife, naked)
</code></pre>

<p>Czech also allows finite clausal complements for nouns with 
a subset of nouns like <em>fact</em> or <em>report</em>.
These look roughly like relative clauses, but do not have any omitted role in the dependent clause.
These are also analyzed as <code>acl</code>.</p>

<pre><code class="language-sdparse">Příčinou není fakt , že by kina navštívilo víc diváků . \n Cause is-not the-fact , that would cinemas visit more filmgoers .
acl(fakt, navštívilo)
acl(the-fact, visit)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/acl.md" target="#">edit acl</a></p>

<p><a id="al-cs-dep/advcl" class="al-dest"></a></p>
<h2><code>advcl</code>: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.),
as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an <a href="">advmod</a>) and the dependent is the main predicate of the clause.</p>

<pre><code class="language-sdparse">K nehodě došlo , když přicházela noc . \n To accident it-came , when was-falling night .
advcl(došlo, přicházela)
advcl(it-came, was-falling)
</code></pre>

<pre><code class="language-sdparse">Jestliže víš , kdo to udělal , měl bys to říct učiteli . \n If you-know , who it did , should you it tell teacher .
advcl(měl, víš)
advcl(should, you-know)
</code></pre>

<pre><code class="language-sdparse">Spěchal , aby přišel včas . \n He-rushed , in-order-to come in-time .
advcl(Spěchal, přišel)
advcl(He-rushed, come)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advcl.md" target="#">edit advcl</a></p>

<p><a id="al-cs-dep/advmod" class="al-dest"></a></p>
<h2><code>advmod</code>: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) <a href="cs-pos/ADV">adverb</a>
or adverbial phrase that serves to modify the meaning of the word.</p>

<p>Note that in the Czech grammatical tradition, the term <em>adverbial modifier</em> covers
constituents that function like adverbs regardless whether they are realized
by adverbs, adpositional phrases, or nouns in particular morphological 
<a href="cs-feat/Case">cases</a>.
We differentiate adverbials realized as adverbs (<code>advmod</code>) and
adverbials realized by noun phrases or adpositional phrases
(<a href="">nmod</a>).</p>

<pre><code class="language-sdparse">geneticky upravené potraviny \n genetically modified food
advmod(upravené, geneticky)
advmod(modified, genetically)
</code></pre>

<pre><code class="language-sdparse">méně často \n less often
advmod(často, méně)
advmod(often, less)
</code></pre>

<pre><code class="language-sdparse">Kam/ADV chcete/VERB jít/VERB zítra/ADV ?/PUNCT \n Where do-you-want to-go tomorrow ?
advmod(jít, Kam)
advmod(jít, zítra)
advmod(to-go, Where)
advmod(to-go, tomorrow)
</code></pre>

<pre><code class="language-sdparse">Na demonstraci přišlo nanejvýš 200 lidí . \n To demonstration came at-most 200 people .
advmod(200-5, nanejvýš)
advmod(200-13, at-most)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advmod.md" target="#">edit advmod</a></p>

<p><a id="al-cs-dep/advmod:emph" class="al-dest"></a></p>
<h2><code>advmod:emph</code>: emphasizing word, intensifier</h2>

<p>This is a special class of <a href="advmod">adverbial modifiers</a>.
It corresponds to the words that are attached in the analytical layer of PDT with the label <code>AuxZ</code>.
In the tectogrammatical layer they often get the label (functor) <code>RHEM</code> (rhematizers).</p>

<pre><code class="language-sdparse">zvlášť v pondělí \n especially on Monday
advmod:emph(pondělí, zvlášť)
advmod:emph(Monday, especially)
</code></pre>

<pre><code class="language-sdparse">jen 15 procent \n only 15 percent
advmod:emph(procent, jen)
advmod:emph(percent, only)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advmod-emph.md" target="#">edit advmod:emph</a></p>

<p><a id="al-cs-dep/amod" class="al-dest"></a></p>
<h2><code>amod</code>: adjectival modifier</h2>

<p>An adjectival modifier of a noun is any adjectival phrase that serves
to modify the meaning of the noun.</p>

<p>Exception: if the modifying adjectival word is pronominal (i.e. tagged <a href="">cs-pos/DET</a>),
the relation is <a href="">det</a> instead of <code>amod</code>.</p>

<pre><code class="language-sdparse">Václav jí vepřové maso . \n Václav eats pork meat .
amod(maso, vepřové)
amod(meat, pork)
</code></pre>

<pre><code class="language-sdparse">Václav si vzal třímiliónovou půjčku . \n Václav himself took-out three-million loan .
amod(půjčku, třímiliónovou)
amod(loan, three-million)
</code></pre>

<pre><code class="language-sdparse">První závodník byl rychlý . \n First racer was fast .
amod(závodník, První)
amod(racer, First)
nsubj(rychlý, závodník)
nsubj(fast, racer)
</code></pre>

<pre><code class="language-sdparse">Rychlý závodník byl první . \n Fast racer was first .
amod(závodník, Rychlý)
amod(racer, Fast)
nsubj(první, závodník)
nsubj(first, racer)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/amod.md" target="#">edit amod</a></p>

<p><a id="al-cs-dep/appos" class="al-dest"></a></p>
<h2><code>appos</code>: appositional modifier</h2>

<p>An appositional modifier of a noun is a nominal immediately following
the first noun that serves to define or modify that noun. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.</p>

<pre><code class="language-sdparse">Karel IV . , římský císař a český král , vládl ve 14 . století . \n Charles IV . , Roman Emperor and Czech king , ruled in 14 th century .
appos(Karel, císař)
appos(Charles, Emperor)
conj(císař, král)
conj(Emperor, king)
</code></pre>

<pre><code class="language-sdparse">Občanská demokratická strana ( ODS ) \n Civic Democratic Party ( ODS )
appos(strana, ODS-5)
appos(Party, ODS-12)
</code></pre>

<p>There is a slight deviation from the <a href="u-dep/appos">universal</a> standard in case of more than one appositive nominal.
Instead of attaching them all to the first noun, all the appositive modifiers are put together in coordination,
then attached as <code>appos</code> to the modified noun.
This is done regardless whether the appositives are joined by a coordinating conjunction or just a comma.</p>

<pre><code class="language-sdparse">Přijel Michal , můj bratr a Davidův bratranec . \n Came Michal , my brother and David's cousin .
appos(Michal-2, bratr)
appos(Michal-12, brother)
conj(bratr, bratranec)
conj(brother, cousin)
</code></pre>

<pre><code class="language-sdparse">Michal , můj bratr , Davidův bratranec , přijede zítra . \n Michal , my brother , David's cousin , will-come tomorrow .
appos(Michal-1, bratr)
appos(Michal-13, brother)
conj(bratr, bratranec)
conj(brother, cousin)
</code></pre>

<p><code>appos</code> is also used to link key-value pairs in addresses, signatures, etc. (see also the <a href="">list</a> label):</p>

<pre><code class="language-sdparse">Jan Novák , tel . : 777-000-111 , e-mail : novak@ab.cz
name(Novák, Jan)
list(Novák, tel)
list(Novák, e-mail)
appos(tel, 777-000-111)
appos(e-mail, novak@ab.cz)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/appos.md" target="#">edit appos</a></p>

<p><a id="al-cs-dep/aux" class="al-dest"></a></p>
<h2><code>aux</code>: auxiliary</h2>

<p>An auxiliary of a clause is a form of the <a href="cs-pos/AUX">auxiliary verb</a> <em>být</em> “to be”
used to construct the periphrastic future tense, past tense or conditional.</p>

<p>Exception: Auxiliary verb used to construct the passive
<a href="cs-feat/Voice">voice</a> is not labeled <code>aux</code> but <a href="">auxpass</a>.</p>

<p>Note that besides <code>aux</code> and <code>auxpass</code>, the verb <em>být</em> may also act as a <a href="cop">copula</a>
and as the main verb.</p>

<pre><code class="language-sdparse">Přijel jsem včera . \n Arrived I-have yesterday .
aux(Přijel, jsem)
aux(Arrived, I-have)
</code></pre>

<pre><code class="language-sdparse">Zítra budu přednášet na univerzitě . \n Tomorrow I-will give-a-talk at university .
aux(přednášet, budu)
aux(give-a-talk, I-will)
</code></pre>

<pre><code class="language-sdparse">Přišel bych dříve , ale ujel mi vlak . \n Come I-would earlier , but missed my train .
aux(Přišel, bych)
aux(Come, I-would)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/aux_.md" target="#">edit aux</a></p>

<p><a id="al-cs-dep/auxpass" class="al-dest"></a></p>
<h2><code>auxpass</code>: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a form of the <a href="cs-pos/AUX">auxiliary verb</a> <em>být</em> “to be”
used to construct the periphrastic passive voice (in any tense or in the infinitive).</p>

<pre><code class="language-sdparse">Kennedy byl zabit . \n Kennedy was killed .
auxpass(zabit, byl)
auxpass(killed, was)
</code></pre>

<pre><code class="language-sdparse">Kennedy bude zabit . \n Kennedy will-be killed .
auxpass(zabit, bude)
auxpass(killed, will-be)
</code></pre>

<pre><code class="language-sdparse">Kennedy netušil , že jeho osudem je být zabit . \n Kennedy did-not-anticipate that his fate is to-be killed .
auxpass(zabit, být)
auxpass(killed, to-be)
</code></pre>

<p>Note that the passive participle may be also used as nominal predicate with <a href="cop">copula</a>.
Hence it may be difficult to distinguish a passive construction from a copula construction.
The former focuses on the process while the latter emphasizes the result.</p>

<ul>
  <li>Passive:</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána v Bílém domě . \n Contract was signed in White House .
auxpass(podepsána, byla)
auxpass(signed, was)
</code></pre>

<ul>
  <li>Copula:</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána červeným inkoustem . \n Contract was signed in-red ink .
cop(podepsána, byla)
cop(signed, was)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/auxpass.md" target="#">edit auxpass</a></p>

<p><a id="al-cs-dep/case" class="al-dest"></a></p>
<h2><code>case</code>: case marking</h2>

<p>Czech uses a combination of oblique morphological cases and prepositions to express semantic case.
Unlike in the original annotation of the Prague Dependency Treebank, prepositions in UD are treated as dependents
of the noun they attach to. The relation between the noun and the preposition is labeled <code>case</code>.</p>

<pre><code class="language-sdparse">V pátek.Acc jsme si cestou.Ins do Francie.Gen povídali o té události.Loc . \n On Friday we-have ourselves during-the-journey to France talked about the event .
case(pátek.Acc, V)
case(Friday, On)
case(Francie.Gen, do)
case(France, to)
case(události.Loc, o)
case(event, about)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/case.md" target="#">edit case</a></p>

<p><a id="al-cs-dep/cc" class="al-dest"></a></p>
<h2><code>cc</code>: coordinating conjunction</h2>

<p>For more on coordination, see the <a href="">conj</a> relation.
A <code>cc</code> is the relation between the first conjunct and
the <a href="cs-pos/CONJ">coordinating conjunction</a> delimiting another conjunct.
(Note: different dependency grammars have different treatments of coordination.
We take the first conjunct as the head of the coordination.)</p>

<pre><code class="language-sdparse">Je to starý a moudrý muž . \n Is he old and wise man .
cc(starý, a)
cc(old, and)
</code></pre>

<p>A coordinating conjunction may also appear at the beginning of a
sentence. This is also called a <code>cc</code>, and it depends on the root
predicate of the sentence.
(In fact there is a coordination that spans multiple sentences.
We cannot attach a word to the first conjunct because it is in another sentence.
Thus we attach it to the first conjunct available in the current sentence: its main predicate.)</p>

<pre><code class="language-sdparse">A pak jsme odešli . \n And then we-have left .
cc(odešli, A)
cc(left, And)
</code></pre>

<pre><code class="language-sdparse">Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
dobj(Máme, jablka)
dobj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(jablka, a)
cc(apples, and)
punct(jablka, ,-3)
punct(jablka, ,-5)
punct(apples, ,-13)
punct(apples, ,-15)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/cc.md" target="#">edit cc</a></p>

<p><a id="al-cs-dep/ccomp" class="al-dest"></a></p>
<h2><code>ccomp</code>: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause 
which is a core argument. That is, it functions like an object of the verb, or
adjective.</p>

<pre><code class="language-sdparse">Říká , že ráda plaveš . \n He-says , that like-to you-swim .
ccomp(Říká, plaveš)
ccomp(He-says, you-swim)
</code></pre>

<p>Such clausal complements may be finite or nonfinite. However, if the
subject of the clausal complement is controlled (that is, must be the same
as the higher subject or object, with no other possible interpretation)
the appropriate relation is <a href="">xcomp</a>.</p>

<pre><code class="language-sdparse">Šéf nám nařídil vykopat příkop . \n Boss us ordered to-dig ditch .
ccomp(nařídil, vykopat)
ccomp(ordered, to-dig)
</code></pre>

<pre><code class="language-sdparse">Začali jsme kopat příkop . \n Started we-have to-dig ditch .
xcomp(Začali, kopat)
xcomp(Started, to-dig)
</code></pre>

<p>The key difference here is that, while it is possible to interpret the first
sentence to mean that the boss will not be doing any digging, in the second
sentence it is clear that the subject of <strong>digging</strong> can only be <strong>we</strong>. This is
what distinguishes <code>ccomp</code> and <code>xcomp</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><a id="al-cs-dep/compound" class="al-dest"></a></p>
<h2><code>compound</code>: compound</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>compound</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/compound.md" target="#">edit compound</a></p>

<p><a id="al-cs-dep/conj" class="al-dest"></a></p>
<h2><code>conj</code>: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as <em>and, or,</em> or a comma or other punctuation.
We treat conjunctions asymmetrically in what is known as the Stanford style:
The head of the relation is the first
conjunct and all the other conjuncts depend on it via the <code>conj</code> relation.</p>

<pre><code class="language-sdparse">Je to starý a moudrý muž . \n Is he old and wise man .
conj(starý, moudrý)
conj(old, wise)
</code></pre>

<pre><code class="language-sdparse">Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
dobj(Máme, jablka)
dobj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(jablka, a)
cc(apples, and)
punct(jablka, ,-3)
punct(jablka, ,-5)
punct(apples, ,-13)
punct(apples, ,-15)
</code></pre>

<p>Coordinate clauses are treated the same way as coordination of other constituent types:</p>

<pre><code class="language-sdparse">Přišel domů , osprchoval se a hned šel do postele . \n He-came home , showered himself and immediately went to bed .
conj(Přišel, osprchoval)
conj(Přišel, šel)
conj(He-came, showered)
conj(He-came, went)
punct(Přišel, ,-3)
punct(He-came, ,-15)
cc(Přišel, a)
cc(He-came, and)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/conj.md" target="#">edit conj</a></p>

<p><a id="al-cs-dep/cop" class="al-dest"></a></p>
<h2><code>cop</code>: copula</h2>

<p>A copula is the relation between the nominal predicate <em>(přísudek jmenný)</em> and
the copular verb <em><b>být</b></em> “to be” (or its variants <em>bývat, bývávat</em>).
The verb <em>stát se</em> “to become”, despite being counted among copular verbs by some authors,
is not analyzed as <code>cop</code>.</p>

<p>We normally take a copula as a dependent of its complement (the nominal predicate).
The nominal predicate is usually a <a href="cs-pos/NOUN">noun</a>, an <a href="cs-pos/ADJ">adjective</a>
or a <a href="cs-feat/VerbForm">participle</a>.</p>

<pre><code class="language-sdparse">Ondřej je čestný muž . \n Ondřej is honest man .
cop(muž, je)
cop(man, is)
</code></pre>

<pre><code class="language-sdparse">Ondřej je čestný . \n Ondřej is honest .
cop(čestný, je)
cop(honest, is)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/cop.md" target="#">edit cop</a></p>

<p><a id="al-cs-dep/csubj" class="al-dest"></a></p>
<h2><code>csubj</code>: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. The dependent is the main lexical verb or other 
predicate of the subject clause.</p>

<pre><code class="language-sdparse">Obžalovanému přitížilo , že neměl alibi . \n To-indictee did-a-disservice , that he-did-not-have alibi .
csubj(přitížilo, neměl)
csubj(did-a-disservice, he-did-not-have)
</code></pre>

<pre><code class="language-sdparse">Podstatou těchto vazeb je , že se děj rozloží na dvě složky . \n The-essence of-these constructions is , that one the-action splits to two parts .
csubj(Podstatou, rozloží)
cop(Podstatou, je)
csubj(The-essence, splits)
cop(The-essence, is)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/csubj.md" target="#">edit csubj</a></p>

<p><a id="al-cs-dep/csubjpass" class="al-dest"></a></p>
<h2><code>csubjpass</code>: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive
clause (or more generally, any voice where the proto-agent argument does not become the subject 
of the clause).</p>

<pre><code class="language-sdparse">Bylo mi doporučeno , abych to velmi dobře zvážil . \n It-has-been to-me recommended , that-I it very well weigh .
csubjpass(doporučeno, zvážil)
csubjpass(recommended, weigh)
</code></pre>

<!--zvratné pasívum:
Nepředpokládá se, že přijdete před devátou.-->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/csubjpass.md" target="#">edit csubjpass</a></p>

<p><a id="al-cs-dep/dep" class="al-dest"></a></p>
<h2><code>dep</code>: unspecified dependency</h2>

<p>A dependency is labeled as <code>dep</code> when a system is unable to
determine a more precise dependency relation between two words.  This
may be because of a weird grammatical construction, a limitation in
software, a parser error, or
because of an unresolved long distance dependency.</p>

<p>Most <code>dep</code> instances in the current conversion of the PDT 3.0 data
correspond to the PDT label <code>ExD</code>, which marks ellipsis.
The current conversion software cannot produce the annotation conforming
to the UD standard and using the <a href="">remnant</a> relation.</p>

<pre><code class="language-sdparse">K čemu ovšem , to nebylo jasné . \n For what however , that was-not clear .
dep(jasné, čemu)
dep(clear, what)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/dep.md" target="#">edit dep</a></p>

<p><a id="al-cs-dep/det" class="al-dest"></a></p>
<h2><code>det</code>: determiner</h2>

<p>The relation determiner (<code>det</code>) holds between a nominal head and its
<a href="u-pos/DET">determiner</a>.
This relation is used for pronominal adjectival modifiers of noun phrases; the <code>det</code> modifier has the POS tag <a href="">cs-pos/DET</a> and vice versa.
Non-pronominal adjectives are tagged <a href="">cs-pos/ADJ</a> and the relation is labeled <a href="">amod</a>.</p>

<pre><code class="language-sdparse">Ten člověk už je tady . \n The man already is here .
det(člověk, Ten)
det(man, The)
</code></pre>

<pre><code class="language-sdparse">Která kniha se vám líbí nejvíc ? \n Which book is to-you nice the-most ?
det(kniha, Která)
det(book, Which)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det.md" target="#">edit det</a></p>

<p><a id="al-cs-dep/discourse" class="al-dest"></a></p>
<h2><code>discourse</code>: discourse element</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>discourse</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/discourse.md" target="#">edit discourse</a></p>

<p><a id="al-cs-dep/dislocated" class="al-dest"></a></p>
<h2><code>dislocated</code>: dislocated elements</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>dislocated</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/dislocated.md" target="#">edit dislocated</a></p>

<p><a id="al-cs-dep/dobj" class="al-dest"></a></p>
<h2><code>dobj</code>: direct object</h2>

<p>The direct object of a verb is the noun phrase that denotes the entity acted upon.
Most often the direct object is in the <a href="cs-feat/Case">accusative case</a> but
there are verbs that require their objects be in other cases (except for
nominative and vocative).</p>

<p>Accusative example:</p>

<pre><code class="language-sdparse">Koupil jsem auto . \n Bought I-have car .
dobj(Koupil, auto)
dobj(Bought, car)
</code></pre>

<p>Genitive example:</p>

<pre><code class="language-sdparse">Cením si vaší pomoci . \n I-appreciate REFLEX your help .
dobj(Cením, pomoci)
dobj(I-appreciate, help)
</code></pre>

<p>Dative example:</p>

<pre><code class="language-sdparse">Čelíme velkým problémům . \n We-face big problems .
dobj(Čelíme, problémům)
dobj(We-face, problems)
</code></pre>

<p>Instrumental example:</p>

<pre><code class="language-sdparse">Univerzita nedisponuje takovým rozpočtem . \n University does-not-have-at-disposal such budget .
dobj(nedisponuje, rozpočtem)
dobj(does-not-have-at-disposal, budget)
</code></pre>

<p>In general, if there is just one object, it should be labeled <code>dobj</code>,
regardless of the morphological case or semantic role that it bears. If there are two or more
objects, one of them should be <code>dobj</code> and the others should be
<a href="">iobj</a>. In such cases it is necessary to decide what is the most
directly affected object <em>(patient).</em> The one exception is when there is a clausal complement. Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj.</p>

<h2 id="diffs">Diffs</h2>

<h3 id="prague-dependency-treebank">Prague Dependency Treebank</h3>

<p>The manual annotation of the PDT does not distinguish direct and indirect objects.
Therefore all non-clausal dependents labeled <code>Obj</code> in PDT are currently labeled <code>dobj</code>
in the converted data, even if it results in two or more direct objects attached to one verb.
In future, the valency lexicon <a href="http://ufal.mff.cuni.cz/vallex">Vallex</a>
could be used to identify the main object.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/dobj.md" target="#">edit dobj</a></p>

<p><a id="al-cs-dep/expl" class="al-dest"></a></p>
<h2><code>expl</code>: expletive</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>expl</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/expl.md" target="#">edit expl</a></p>

<p><a id="al-cs-dep/foreign" class="al-dest"></a></p>
<h2><code>foreign</code>: foreign words</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>foreign</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/foreign.md" target="#">edit foreign</a></p>

<p><a id="al-cs-dep/goeswith" class="al-dest"></a></p>
<h2><code>goeswith</code>: goes with</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>goeswith</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/goeswith.md" target="#">edit goeswith</a></p>

<p><a id="al-cs-dep/iobj" class="al-dest"></a></p>
<h2><code>iobj</code>: indirect object</h2>

<p>The indirect object of a verb is any nominal phrase that is a core
argument of the verb but is not its subject or <a href="dobj">direct object</a>.
The prototypical example is the recipient of ditransitive verbs of
exchange:</p>

<pre><code class="language-sdparse">Pavel dal Petrovi dvě hrušky . \n Pavel gave Petr two pears .
iobj(dal, Petrovi)
iobj(gave, Petr)
</code></pre>

<p>However, Czech allows other semantic roles as additional objects.
The morphological <a href="">cs-feat/Case</a> of the objects is dictated by verb valency.</p>

<p>In the following Czech example, the verb takes two arguments, both are nouns in the accusative case. One of them is direct object (patient), the other is indirect (addressee). It is parallel to how the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving (consider a similar sentence, <em>he gave my daughter a class of maths</em>).</p>

<pre><code class="language-sdparse">On učí mou dceru matematiku . \n He teaches my daughter.Acc maths.Acc .
dobj(učí, matematiku)
iobj(učí, dceru)
dobj(teaches, maths.Acc)
iobj(teaches, daughter.Acc)
</code></pre>

<p>In general, if there is just one object, it should be labeled
<a href="">dobj</a>, regardless of the morphological case or semantic role.
For example, <em>učit</em> “to teach” can take either the subject matter or the recipient as the only object,
and in both cases it would be analyzed ad the <a href="">dobj</a>:</p>

<pre><code class="language-sdparse">Učí úvod do logiky . \n He-teaches introduction to logic .
dobj(Učí, úvod)
dobj(He-teaches, introduction)
</code></pre>

<pre><code class="language-sdparse">Učí studenty prvního ročníku . \n He-teaches students of-first year .
dobj(Učí, studenty)
dobj(He-teaches, students)
</code></pre>

<p>The one exception is when there is a clausal complement.
Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj, parallel to
the simple ditransitive case:</p>

<pre><code class="language-sdparse">Řekla studentům , že dnes večer musí studovat . \n She-told students , that today evening they-needed to-study .
iobj(Řekla, studentům)
ccomp(Řekla, musí)
iobj(She-told, students)
ccomp(She-told, they-needed)
</code></pre>

<pre><code class="language-sdparse">Řekla studentům svůj plán . \n She-told students her plan .
iobj(Řekla, studentům)
dobj(Řekla, plán)
iobj(She-told, students)
dobj(She-told, plan)
</code></pre>

<p>If there are two or
more objects, one of them should be <a href="">dobj</a> and the others should be
<code>iobj</code>. In such cases it is necessary to decide what is the
most directly affected object <em>(patient).</em></p>

<h2 id="diffs">Diffs</h2>

<h3 id="prague-dependency-treebank">Prague Dependency Treebank</h3>

<p>The manual annotation of the PDT does not distinguish direct and indirect objects.
Therefore all non-clausal dependents labeled <code>Obj</code> in PDT are currently labeled <code>dobj</code>
in the converted data, even if it results in two or more direct objects attached to one verb.
In future, the valency lexicon <a href="http://ufal.mff.cuni.cz/vallex">Vallex</a>
could be used to identify the main object.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/iobj.md" target="#">edit iobj</a></p>

<p><a id="al-cs-dep/list" class="al-dest"></a></p>
<h2><code>list</code>: list</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>list</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/list.md" target="#">edit list</a></p>

<p><a id="al-cs-dep/mark" class="al-dest"></a></p>
<h2><code>mark</code>: marker</h2>

<p>A marker is the subordinating conjunction introducing a finite clause subordinate to another clause.
The mark is a dependent of the subordinate clause head.</p>

<pre><code class="language-sdparse">Nevěděl jsem , že umíš německy . \n Not-know I-did , that you-can-speak German .
mark(umíš, že)
mark(you-can-speak, that)
</code></pre>

<pre><code class="language-sdparse">Zboží odešleme , jakmile peníze dorazí na náš účet . \n Goods we-will-dispatch , as-soon-as money arrive at our account .
mark(dorazí, jakmile)
mark(arrive, as-soon-as)
</code></pre>

<p>Note that the subordinating conjunction should not be confused with relative pronouns and adverbs.
These fill a valency slot in the frame of the subordinate predicate,
and are labeled according to their role in the frame, they are not <code>mark</code>:</p>

<pre><code class="language-sdparse">Rád bych věděl , kdy peníze dorazí na náš účet . \n Like-to I-would know , when money arrive at our account .
advmod(dorazí, kdy)
advmod(arrive, when)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/mark.md" target="#">edit mark</a></p>

<p><a id="al-cs-dep/mwe" class="al-dest"></a></p>
<h2><code>mwe</code>: multi-word expression</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>mwe</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/mwe.md" target="#">edit mwe</a></p>

<p><a id="al-cs-dep/mwe:reflex" class="al-dest"></a></p>
<h2><code>mwe:reflex</code>: reflexive verb</h2>

<p>Reflexive pronouns (see the feature <a href="">cs-feat/Reflex</a>) usually replace objects of verbs.
However, some verbs are obligatorily reflexive, i.e. the verb always occurs with a reflexive
prounoun. With these verbs, the reflexive pronoun is not attached as <a href="">dobj</a>
but as a special sort of <code>mwe</code> relation.</p>

<pre><code class="language-sdparse">Martin se bojí zvířat .
mwe:reflex(bojí, se)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/mwe-reflex.md" target="#">edit mwe:reflex</a></p>

<p><a id="al-cs-dep/name" class="al-dest"></a></p>
<h2><code>name</code>: name</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>name</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/name.md" target="#">edit name</a></p>

<p><a id="al-cs-dep/neg" class="al-dest"></a></p>
<h2><code>neg</code>: negation modifier</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>neg</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/neg.md" target="#">edit neg</a></p>

<p><a id="al-cs-dep/nmod" class="al-dest"></a></p>
<h2><code>nmod</code>: nominal modifier</h2>

<p>The <code>nmod</code> relation is used for nominal modifiers. They depend either
on another noun (group “noun dependents”) or on a predicate (group
“non-core dependents of clausal predicates”).</p>

<p><code>nmod</code> is a <a href="cs-pos/NOUN">noun</a> (or noun phrase) functioning as a
non-core (oblique) argument or adjunct.
This means that it functionally corresponds to an adverbial when it attaches to a verb, adjective or other adverb.
But when attaching to a noun, it corresponds to a non-agreeing attribute <em>(přívlastek neshodný)</em>
in genitive.</p>

<p>In Czech the <code>nmod</code> relation covers only those possessives that are expressed using the genitive <a href="">cs-feat/Case</a>.
If a possessive adjective is used, the relation is labeled <a href="">amod</a>.</p>

<pre><code class="language-sdparse">kancelář ředitele \n office of-the-director
nmod(kancelář, ředitele)
nmod(office, of-the-director)
</code></pre>

<pre><code class="language-sdparse">ředitelova kancelář \n director's office
amod(kancelář, ředitelova)
amod(office, director's)
</code></pre>

<pre><code class="language-sdparse">jeho kancelář \n his office
det(kancelář, jeho)
det(office, his)
</code></pre>

<p><code>nmod</code> is also used for temporal nominal modifiers:</p>

<pre><code class="language-sdparse">Potkal jsem ho minulý čtvrtek . \n Met I-have him last Thursday .
nmod(Potkal, čtvrtek)
nmod(Met, Thursday)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nmod.md" target="#">edit nmod</a></p>

<p><a id="al-cs-dep/nsubj" class="al-dest"></a></p>
<h2><code>nsubj</code>: nominal subject</h2>

<p>A nominal subject is a nominal phrase which is the syntactic subject of a clause;
in Czech, the phrase is in the nominative <a href="">cs-feat/Case</a>.
(See <a href="">csubj</a> for when the subject is clausal.
See <a href="">nsubjpass</a> and <a href="">csubjpass</a> for when the subject is not the proto-agent argument due to valence changing operations.)
The governor of the <code>nsubj</code> relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun.</p>

<pre><code class="language-sdparse">Novosvětskou symfonii napsal Antonín Dvořák . \n From-the-New-World Symphony wrote Antonín Dvořák .
nsubj(napsal, Dvořák-5)
nsubj(wrote, Dvořák-12)
</code></pre>

<pre><code class="language-sdparse">Auto je červené . \n Car is red .
nsubj(červené, Auto)
nsubj(red, Car)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nsubj.md" target="#">edit nsubj</a></p>

<p><a id="al-cs-dep/nsubjpass" class="al-dest"></a></p>
<h2><code>nsubjpass</code>: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause (or more generally, any voice where the proto-agent argument does not become the subject of the clause).</p>

<pre><code class="language-sdparse">Schwarzenberg byl poražen Zemanem . \n Schwarzenberg was defeated by-Zeman .
nsubjpass(poražen, Schwarzenberg-1)
nsubjpass(defeated, Schwarzenberg-7)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nsubjpass.md" target="#">edit nsubjpass</a></p>

<p><a id="al-cs-dep/nummod" class="al-dest"></a></p>
<h2><code>nummod</code>: numeric modifier</h2>

<p>A numeric modifier of a noun is any <a href="u-pos/NUM">number</a> phrase
that serves to modify the meaning of the noun with a quantity.</p>

<pre><code class="language-sdparse">Jan snědl tři řízky . \n Jan ate three steaks .
nummod(řízky, tři)
nummod(steaks, three)
</code></pre>

<h2 id="agreement-and-government-with-czech-quantifiers">Agreement and government with Czech quantifiers</h2>

<p>The morphological and syntactic behavior of Czech numerals is a complex matter.
Small cardinal numerals <em>jeden</em> “one”, <em>dva</em> “two”, <em>tři</em> “three” and <em>čtyři</em> “four” agree with the counted
noun in <a href="">cs-feat/Case</a> (<em>jeden</em> also agrees in <a href="">cs-feat/Gender</a> and <a href="">cs-feat/Number</a>;
<em>dva</em> also agrees in <a href="">cs-feat/Gender</a>).
They behave as if they modify the counted noun; they are similar to adjectives in this respect.
Examples:</p>

<ul>
  <li><em><b>Jeden</b> muž spal, <b>dva</b> muži hráli karty.</em> “One man slept, two men played cards.”</li>
  <li><em><b>Jedna</b> žena spala, <b>dvě</b> ženy hrály karty.</em> “One woman slept, two women played cards.”</li>
  <li><em><b>Jedno</b> kotě spalo, <b>dvě</b> koťata si hrála.</em> “One kitten slept, two kittens played.”</li>
</ul>

<p>In PDT, these numerals are attached to their counted nouns as <code>Atr</code> (attribute).
It is straightforward to convert such dependencies to <code>nummod</code>:</p>

<pre><code class="language-sdparse">Jedno kotě spalo . \n One kitten slept .
nummod(kotě, Jedno)
nsubj(spalo, kotě)
punct(spalo, .)
</code></pre>

<p>Larger cardinals behave differently.
They require that the counted noun be in the genitive case; this indicates that they actually govern the noun.
Such constructions are parallel to nouns modified by other noun phrases in genitive.
The whole phrase (numeral + counted noun) behaves as a noun phrase in neuter gender and singular number
(which is important for subject-verb agreement).</p>

<ul>
  <li><em><b>Pět</b> mužů hrálo karty.</em> “Five men played cards.”</li>
  <li><em>Skupina mužů hrála karty.</em> “A group of men played cards.”</li>
</ul>

<p>In PDT, these numerals are analyzed as heads of the counted nouns, which are attached to the numeral as <code>Atr</code>:</p>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Pět     pět     NUM     _   Case=Nom                           3   Sb     _   Five
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   .       .       PUNCT   _   _                                  0   AuxK   _   .
</code></pre>

<p>There are both advantages and drawbacks to this solution.
On the one hand, it reflects well the agreement in case, gender and number.
On the other hand, it is confusing that there are two different analyses of counted noun constructions,
depending on the numeric value.</p>

<p>Moreover, the numeral does not govern the noun in all morphological cases.
The following table shows the case of the whole phrase (numeral + noun; first column)
and the consequences for the case of the parts (note that these numerals have only
two distinct morphological forms, resulting in homonymy).</p>

<table>
<tr><th>Phrase Case</th><th>Example</th><th>Numeral Case</th><th>Noun Case</th></tr>
<tr><td>Nom</td><td>pět mužů</td>   <td>Nom</td><td>Gen</td></tr>
<tr><td>Gen</td><td>pěti mužů</td>  <td>Gen</td><td>Gen</td></tr>
<tr><td>Dat</td><td>pěti mužům</td> <td>Dat</td><td>Dat</td></tr>
<tr><td>Acc</td><td>pět mužů</td>   <td>Acc</td><td>Gen</td></tr>
<tr><td>Voc</td><td>pět mužů</td>   <td>Voc</td><td>Gen</td></tr>
<tr><td>Loc</td><td>pěti mužích</td><td>Loc</td><td>Loc</td></tr>
<tr><td>Ins</td><td>pěti muži</td>  <td>Ins</td><td>Ins</td></tr>
</table>

<p>We can say that the noun has the case of the whole phrase if it is dative, locative or instrumental.
The numeral then agrees with the noun in case.
The numeral forces the noun to the genitive case if the whole phrase is nominative, accusative or vocative
(but the vocative usage is rather hypothetical).
In genitive, the noun and the numeral agree with each other; but note that the numeral uses its
inflected form, as in the other cases where it agrees with the noun.</p>

<p>In PDT, the genitive, dative, locative and instrumental cases are analyzed in parallel to the low-value numerals,
i.e. the noun governs the numeral:</p>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Hrál      hrát    VERB    _   Gender=Masc|Number=Sing            0   Pred   _   He-played
2   karty     karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    1   Obj    _   cards
3   s         s       ADP     _   _                                  1   AuxP   _   with
4   pěti      pět     NUM     _   Case=Ins                           6   Atr    _   five
5   dalšími   další   ADJ     _   Case=Ins|Gender=Masc|Number=Plur   6   Atr    _   other
6   muži      muž     NOUN    _   Case=Ins|Gender=Masc|Number=Plur   3   Obj    _   men
7   .         .       PUNCT   _   _                                  0   AuxK   _   .
</code></pre>

<p>High-value numerals where the lowest-order digit is more than zero and less than five (e.g. 21, 22, 23, 24) may behave both ways:</p>

<ul>
  <li><em>dvacet <b>dva</b> muži</em> (noun governs numeral)</li>
  <li><em>dvacet <b>dva</b> mužů</em> (numeral governs noun)</li>
  <li><em><b>dvaadvacet</b> mužů</em> (alternative form; it does not end with <em>dva</em>, thus the numeral governs the noun)</li>
  <li><em><b>22</b> muži</em> (assuming the reader will pronounce <em>22</em> as <em>dvacet dva,</em> not <em>dvaadvacet</em>)</li>
  <li><em><b>22</b> mužů</em> (pronounced either way)</li>
</ul>

<p>Pronominal quantifiers behave as high-value numerals and govern the quantifed nouns:</p>

<ul>
  <li><em><b>Kolik</b> mužů hrálo karty?</em> “How many men played cards?”</li>
  <li><em><b>Několik</b> (<b>mnoho</b>, <b>málo</b>) mužů hrálo karty.</em> “Several (many, few) men played cards.”</li>
  <li><em><b>Tolik</b> mužů hrát karty jsem ještě neviděl.</em> “I have never seen so many men playing cards.”</li>
</ul>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Kolik   kolik   NUM     _   Case=Nom                           3   Sb     _   How-many
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   ?       ?       PUNCT   _   _                                  0   AuxK   _   ?
</code></pre>

<p>The UD conversion of the PDT data unifies analyses of counted noun phrases
and uses a structure that is parallel among all the above cases,
and also with universal dependencies in other languages.
The counted noun is always the head and the numeral is always attached as its modifier.
Nevertheless, we use different relation labels to mark situations where the numeral (or quantifier)
actually governs the morphological case of the noun.
There are four labels used:</p>

<table>
<tr><td></td><td><strong>Numeric</strong></td><td><strong>Pronominal</strong></td></tr>
<tr><td><strong>Noun governs</strong></td><td><tt>nummod</tt></td><td><tt><a href="det-nummod.html">det:nummod</a></tt></td></tr>
<tr><td><strong>Numeral governs</strong></td><td><tt><a href="nummod-gov.html">nummod:gov</a></tt></td><td><tt><a href="det-numgov.html">det:numgov</a></tt></td></tr>
</table>

<pre><code class="language-sdparse">Tři muži hráli karty . \n Three men played cards .
nummod(muži, Tři)
nsubj(hráli, muži)
dobj(hráli, karty)
punct(hráli, .-5)
nummod(men, Three)
nsubj(played, men)
dobj(played, cards)
punct(played, .-11)
</code></pre>

<pre><code class="language-sdparse">Pět mužů hrálo karty . \n Five men played cards .
nummod:gov(mužů, Pět)
nsubj(hrálo, mužů)
dobj(hrálo, karty)
punct(hrálo, .-5)
nummod:gov(men, Five)
nsubj(played, men)
dobj(played, cards)
punct(played, .-11)
</code></pre>

<pre><code class="language-sdparse">Kolik mužů hrálo karty ? \n How-many men played cards ?
det:numgov(mužů, Kolik)
nsubj(hrálo, mužů)
dobj(hrálo, karty)
punct(hrálo, ?-5)
det:numgov(men, How-many)
nsubj(played, men)
dobj(played, cards)
punct(played, ?-11)
</code></pre>

<pre><code class="language-sdparse">Hrál jsem karty s pěti muži . \n Played I-have cards with five men .
aux(Hrál, jsem)
dobj(Hrál, karty)
iobj(Hrál, muži)
case(muži, s)
nummod(muži, pěti)
punct(Hrál, .-7)
aux(Played, I-have)
dobj(Played, cards)
iobj(Played, men)
case(men, with)
nummod(men, five)
punct(Played, .-15)
</code></pre>

<pre><code class="language-sdparse">Nepamatuji si , s kolika muži jsem hrál karty . \n I-do-not-remember myself , with how-many men I-have played cards .
ccomp(Nepamatuji, hrál)
mwe:reflex(Nepamatuji, si)
punct(hrál, ,-3)
aux(hrál, jsem)
dobj(hrál, karty)
iobj(hrál, muži)
case(muži, s)
det:nummod(muži, kolika)
punct(Nepamatuji, .-10)
ccomp(I-do-not-remember, played)
mwe:reflex(I-do-not-remember, myself)
punct(played, ,-14)
aux(played, I-have)
dobj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-do-not-remember, .-21)
</code></pre>

<h2 id="additional-remarks">Additional remarks</h2>

<p>In PDT the words <em>milión</em> “million”, <em>miliarda</em> “billion” and higher are usually tagged as <a href="cs-pos/NOUN">nouns</a>,
not as <a href="cs-pos/NUM">numerals</a>.
In the typical case, the million is in genitive, it is preceded by a smaller number,
and it is not followed by smaller numerals (as it is in <em>million five hundred thousand</em>).
It is followed by the counted noun.
Thus the following examples receive parallel analyses:</p>

<pre><code class="language-sdparse">50 miliónů korun \n 50 millions of-crowns
nummod:gov(miliónů, 50-1)
nummod:gov(millions, 50-5)
nmod(miliónů, korun)
nmod(millions, of-crowns)
</code></pre>

<pre><code class="language-sdparse">50 pytlů bankovek \n 50 sacks of-bills
nummod:gov(pytlů, 50-1)
nummod:gov(sacks, 50-5)
nmod(pytlů, bankovek)
nmod(sacks, of-bills)
</code></pre>

<p>On the other hand the word <em>tisíc</em> “thousand” may be a noun
(<em>na náměstí byly tisíce lidí</em> “there were thousands of people in the square”)
or a numeral:</p>

<pre><code class="language-sdparse">nanejvýš 50 tisíc korun \n at-most 50 thousand crowns
advmod:emph(korun, nanejvýš)
nummod:gov(korun, tisíc)
compound(tisíc, 50-2)
advmod:emph(crowns, at-most)
nummod:gov(crowns, thousand)
compound(thousand, 50-7)
</code></pre>

<p>Note that the two numeral words in the above example are joined using the <a href="">compound</a> relation.
Also note that the <a href="advmod:emph">intensifier</a> <em>nanejvýš</em> is attached to the head of the phrase <em>(korun)</em> and not to the number.
This is in accord both with the UD guidelines
and with the original PDT annotation of agreeing numerals (e.g. <em>jen čtyři firmy, jen několik procent</em>).</p>

<p>Similarly there may be other nodes (such as punctuation) that are attached to the head of the phrase
and they are related to the whole phrase rather than directly to the head noun:</p>

<pre><code class="language-sdparse">( 9 dní ) \n ( 9 days )
punct(dní, (-1)
nummod:gov(dní, 9)
punct(dní, )-4)
</code></pre>

<p>Na číselné frázi můžou viset i jiné věci než rematizátory.
Tohle bych pak pověsil na minuty, zatímco ta AuxZ bych nechal na číslovce.</p>

<pre><code class="language-sdparse">5 minut včetně seřízení \n 5 minutes including adjustment
nummod:gov(minut, 5)
nmod(minut, seřízení)
case(seřízení, včetně)
</code></pre>

<h2 id="dates">Dates</h2>

<!-- mf920922_027.a.gz (3/19) -->
<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1    Ředitel         ředitel         NOUN    _   _   2   Sb     _   The-director
2    navrhl          navrhnout       VERB    _   _   0   Pred   _   proposed
3    zrušit          zrušit          VERB    _   _   2   Obj    _   to-disband
4    profesionální   profesionální   ADJ     _   _   5   Atr    _   the-professional
5    scénu           scéna           NOUN    _   _   3   Obj    _   scene
6    k               k               ADP     _   _   3   AuxP   _   towards
7    31              31              NUM     _   _   9   Atr    _   the-31
8    .               .               PUNCT   _   _   7   AuxG   _   th
9    12              12              NUM     _   _   6   Adv    _   December
10   .               .               PUNCT   _   _   9   AuxG   _   .
</code></pre>

<pre><code class="language-sdparse">Ředitel navrhl zrušit profesionální scénu k 31 . 12 . \n Director proposed to-disband professional scene towards 31 st December .
advmod(zrušit, 12)
case(12, k)
punct(12, .-10)
nummod(12, 31-7)
punct(31-7, .-8)
advmod(to-disband, December)
case(December, towards)
punct(December, .-21)
nummod(December, 31-18)
punct(31-18, st)
</code></pre>

<p>Numerals expressed using digits are labeled <code>nummod</code> even if they represent ordinal numerals,
which would be labeled <code>amod</code>:</p>

<!-- ln95045_123.a.gz (8/8) -->
<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1    Letošní     letošní      ADJ     _   _   2   Atr    _   This-year's
2    veletrh     veletrh      NOUN    _   _   4   Sb     _   fair
3    se          se           PRON    _   _   4   AuxR   _   itself
4    uskuteční   uskutečnit   VERB    _   _   0   Pred   _   will-take-place
5    od          od           ADP     _   _   4   AuxP   _   from
6    9           9            NUM     _   _   5   ExD    _   9
7    .           .            PUNCT   _   _   6   AuxG   _   th
8    do          do           ADP     _   _   4   AuxP   _   to
9    12          12           NUM     _   _   11  Atr    _   12
10   .           .            PUNCT   _   _   9   AuxG   _   th
11   března      březen       NOUN    _   _   8   Adv    _   March
12   .           .            PUNCT   _   _   0   AuxK   _   .
</code></pre>
<pre><code class="language-sdparse">Letošní veletrh se uskuteční od 9 . do 12 . března . \n This-year's fair itself will-take-place from 9 th to 12 th March .
advmod(uskuteční, března)
case(března, do)
nummod(března, 12-9)
remnant(12-9, 9-6)
remnant(do, od)
advmod(will-take-place, March)
case(March, to)
nummod(March, 12-22)
remnant(12-22, 9-19)
remnant(to, from)
</code></pre>

<h2 id="numbered-objects">Numbered objects</h2>

<p>House number in address is attached as <code>nummod</code> to the name of the street:</p>

<pre><code class="language-sdparse">v budově Na poříčí 12 \n in the-building Na poříčí 12
nmod(budově, poříčí-4)
case(poříčí-4, Na-3)
nummod(poříčí-4, 12-5)
nmod(the-building, poříčí-10)
case(poříčí-10, Na-9)
nummod(poříčí-10, 12-11)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nummod.md" target="#">edit nummod</a></p>

<p><a id="al-cs-dep/parataxis" class="al-dest"></a></p>
<h2><code>parataxis</code>: parataxis</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>parataxis</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/parataxis.md" target="#">edit parataxis</a></p>

<p><a id="al-cs-dep/punct" class="al-dest"></a></p>
<h2><code>punct</code>: punctuation</h2>

<p>This is used for any piece of punctuation in a clause.</p>

<pre><code class="language-sdparse">Jdi domů ! \n Go home !
punct(Jdi, !-3)
punct(Go, !-7)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/punct.md" target="#">edit punct</a></p>

<p><a id="al-cs-dep/remnant" class="al-dest"></a></p>
<h2><code>remnant</code>: remnant in ellipsis</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>remnant</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/remnant.md" target="#">edit remnant</a></p>

<p><a id="al-cs-dep/reparandum" class="al-dest"></a></p>
<h2><code>reparandum</code>: overridden disfluency</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>reparandum</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/reparandum.md" target="#">edit reparandum</a></p>

<p><a id="al-cs-dep/root" class="al-dest"></a></p>
<h2><code>root</code>: root</h2>

<p>The <code>root</code> grammatical relation points to the root of the sentence. A
fake node <code>ROOT</code> is used as the governor. The <code>ROOT</code> node is indexed
with 0, since the indexing of real words in the sentence starts at 1.</p>

<pre><code class="language-sdparse">ROOT Miluju indická jídla . \n ROOT I-love Indian food .
root(ROOT-1, Miluju)
root(ROOT-7, I-love)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/root.md" target="#">edit root</a></p>

<p><a id="al-cs-dep/vocative" class="al-dest"></a></p>
<h2><code>vocative</code>: vocative</h2>

<p>This document is a placeholder for the language-specific documentation
for <code>vocative</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/vocative.md" target="#">edit vocative</a></p>

<p><a id="al-cs-dep/xcomp" class="al-dest"></a></p>
<h2><code>xcomp</code>: open clausal complement</h2>

<p>An open clausal complement (<code>xcomp</code>) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the object of the next higher
clause, if there is one, or else by the subject of the next higher
clause). This is often referred to as <em>obligatory control</em>. 
These complements are always non-finite, and they are
complements (arguments of the higher verb or adjective) rather than
adjuncts/modifiers, such as a purpose clause. The name <code>xcomp</code> is
borrowed from Lexical-Functional Grammar.</p>

<pre><code class="language-sdparse">Nechceš si zaplavat ? \n Don't-you-want yourself to-swim ?
xcomp(Nechceš, zaplavat)
xcomp(Don't-you-want, to-swim)
</code></pre>

<pre><code class="language-sdparse">Začal jsem tam pracovat včera . \n Started I-have there to-work yesterday .
xcomp(Začal, pracovat)
xcomp(Started, to-work)
</code></pre>

<p>Note that the above condition “without its own subject” does not mean that a 
clause is an <code>xcomp</code> just because its subject is not <em>overt.</em>
The subject must be necessarily inherited from a fixed position in the higher clause.
That is, there should be no available interpretation where the subject of the lower clause may be distinct
from the specified role of the upper clause.
In cases where the missing subject may or must be distinct from a fixed role in the higher clause,
<a href="">ccomp</a> should be used instead, as below.  This includes cases of arbitrary subjects and anaphoric control.</p>

<pre><code class="language-sdparse">Šéf nařídil vykopat příkop . \n Boss ordered to-dig ditch .
ccomp(nařídil, vykopat)
ccomp(ordered, to-dig)
</code></pre>

<p>Pro-drop languages have clauses where the subject is not present as a separate word,
yet it is inherently present (and often deducible from the form of the verb)
and it does not depend on arguments from a higher clause.
Thus in neither of the following two Czech examples is there any overt subject,
yet only the second example contains an <code>xcomp</code>.</p>

<pre><code class="language-sdparse">Píšu , protože jsem to slíbil . \n I-write , because I-have it promised .
advcl(Píšu, slíbil)
advcl(I-write, promised)
</code></pre>

<pre><code class="language-sdparse">Slíbil jsem psát . \n Promised I-have to-write .
xcomp(Slíbil, psát)
xcomp(Promised, to-write)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/xcomp.md" target="#">edit xcomp</a></p>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'http://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'http://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'cs-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.github.io/docs/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
